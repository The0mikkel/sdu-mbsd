/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Plus
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject
import dk.sdu.mmmi.mdsd.math.VariableUse
import dk.sdu.mmmi.mdsd.math.Multi
import dk.sdu.mmmi.mdsd.math.Maths
import dk.sdu.mmmi.mdsd.math.SubMathExp
import java.util.List
import java.util.LinkedList
import dk.sdu.mmmi.mdsd.math.SubMath
import dk.sdu.mmmi.mdsd.math.ExternalCall
import java.util.stream.IntStream
import dk.sdu.mmmi.mdsd.math.External
import dk.sdu.mmmi.mdsd.math.ExternalAttribute

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, String> variables = new HashMap();
	static Map<String, List<MathExp>> deferredCalculation = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val maths = resource.allContents.filter(Maths).next
		
		var result = maths.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		// variables.displayPanel
		
		result.generateFile(fsa, maths)
	}
	
	def static compute(Maths math) {
		variables.clear
		for (exp : math.expressions) {
			exp.compute
		}
		
		// Announce variables missing
		deferredError()
		deferredCalculation.clear()
		
		return variables
	}
	
	def static runDeferred(MathExp math) {
		var variableName = math.variable.name
		var deferredExists = deferredCalculation.containsKey(variableName)
		if (deferredExists) {
			var deferredList = deferredCalculation.get(variableName)
			deferredCalculation.remove(variableName)
			for (deferedMath : deferredList) {
				System.out.println("Found " + deferedMath.variable.name + " as deferred from " + variableName)
				deferedMath.compute
			}
		}
	}
	
	def static deferredError() {
		var keys = deferredCalculation.keySet
		var message = ""
		
		if (keys.empty) {
			return
		}
		
		for (key : keys) {
			var list = deferredCalculation.get(key)
			message += "Missing variable " + key + " caused variables " + list.map[it.variable.name].join(", ") + " to not be calculated\n"
		}
		
		JOptionPane.showMessageDialog(null, message, "Missing variables", JOptionPane.ERROR_MESSAGE)
	}
	
	def static Map<String, String> compute(MathExp math) {
		var variableName = math.variable.name
		var result = "";
		
		try {			
			result = math.exp.computeExp
			System.out.println(math.variable.name + ": " +result)
			variables.put(math.variable.name, result);
			
			math.runDeferred
		} catch (VariableNotFound notFound) {			
			var defered = deferredCalculation.get(notFound.variable);
			if (defered === null) {
				defered = new LinkedList();
				deferredCalculation.put(notFound.variable, defered)
			}
			defered.add(math);
			System.out.println("Deferred calculation of " + variableName + " until " + notFound.variable + " is calculated")
			
			return variables;
		}
		
		return variables
	}
	
	dispatch def static String computeExp(Exp exp) {
		val expression = exp.expression
		
		return expression.computeExp
	}
	
	dispatch def static String computeExp(dk.sdu.mmmi.mdsd.math.Number number) {
		return number.value.toString()
	}
	
	dispatch def static String computeExp(Plus plus) {
		return '''«plus.left.computeExp» + «plus.right.computeExp»'''
	}
	
	dispatch def static String computeExp(Minus minus) {
		return '''«minus.left.computeExp» - «minus.right.computeExp»'''
	}
	
	dispatch def static String computeExp(Multi multi) {
		return '''«multi.left.computeExp» * «multi.right.computeExp»'''
	}
	
	dispatch def static String computeExp(Div div) {
		return '''«div.left.computeExp» / «div.right.computeExp»'''
	}
	
	dispatch def static String computeExp(SubMath sub) {
		return sub.sub.computeExp
	}
	
	dispatch def static String computeExp(SubMathExp sub) {
		var variable = sub.variable.name
		
		var existing = ""
		var exists = false
		if (variables.containsKey(variable)) {
			exists = true
			existing = variables.get(variable);
		}
		
		var value = sub.value.computeExp
		variables.put(variable, value)
		
		var expression = sub.exp.get(0)
		var result = expression.computeExp
		variables.remove(variable)
		
		
		if (exists) {
			variables.put(variable, existing)
		}
		
		return result
	}
	
	dispatch def static String computeExp(VariableUse variable) {
		var variableName = variable.ref.getName
		if (!variables.containsKey(variableName)) {
			throw new VariableNotFound(variableName)
		}
		
		return variables.get(variableName)
	}
	
	dispatch def static String computeExp(ExternalCall call) {
		return '''this.external.«call.method.name»(«call.attributes.externalCallAttributesToList.map[it.computeExp].join(", ")»)'''
	}
	
	def static LinkedList<EObject> externalCallAttributesToList(ExternalAttribute attribute) {
		var list = new LinkedList<EObject>();
		
		if (attribute === null) {
			return list;
		}
		
		if (attribute instanceof Exp) {
			list.add(attribute);
			return list;
		}
		
		if (attribute.left instanceof Exp) {
			list.add(attribute.left)
		} else if (attribute.left !== null) {
			var left = attribute.left
			if (left instanceof ExternalAttribute) {				
				var data = externalCallAttributesToList(left)
				list.addAll(data)
			}
		}
		
		if (attribute.right !== null) {
			list.add(attribute.right)
		}

		return list;
	}
	
	def static String getAttributeList(Exp attribute) {
		return attribute.computeExp
	}
	
	dispatch def static String computeExp(EObject object) {
		System.out.println("Found unknown object")
		System.out.println(object)
		return "";
	}
	
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def generateFile(Map<String, String> result, IFileSystemAccess2 fsa, Maths maths) {
		fsa.generateFile('output.java', '''
package math_expression;
public class «maths.program.name» {
	«FOR entry : result.entrySet()»
	public int «entry.getKey()»;
	«ENDFOR»
	
	private External external;
	
	public «maths.program.name»(External external) {
	    this.external = external;
	}
	
	public void compute() {
		«FOR entry : result.entrySet()»
		«entry.getKey()» = «entry.getValue()»;
		«ENDFOR»
	}
	
	interface External {
		«FOR externalMethod : maths.externals»
		public int «externalMethod.name»(«getParameterList(externalMethod)»);
		«ENDFOR»
	}
}
		''')
	}
	
	def String getParameterList(External external) {
		var parameters = new LinkedList<String>();
		for (var i = 0 ; i < external.parameters.length ; i++) {
			parameters.add("int n"+i)
		}
		return parameters.join(", ")
	}
}
